<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Lab03_Struct | BUTLER36HUS&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="ICS-53Struct&lt;stdio.h&gt;Strings &amp; &lt;string.h&gt; Copy  strcpy   strlen  strchr ≈ python find()  loop  for(char* i&#x3D;line;*i;++i) 当*i&#x3D;&#x3D;\EOF时，即末尾时，停止     Formatted strings  int sscanf(char *strin">
<meta property="og:type" content="article">
<meta property="og:title" content="Lab03_Struct">
<meta property="og:url" content="http://butler36hus.github.io/blog/2022/01/09/Lab03-Struct/index.html">
<meta property="og:site_name" content="BUTLER36HUS&#39;s Blog">
<meta property="og:description" content="ICS-53Struct&lt;stdio.h&gt;Strings &amp; &lt;string.h&gt; Copy  strcpy   strlen  strchr ≈ python find()  loop  for(char* i&#x3D;line;*i;++i) 当*i&#x3D;&#x3D;\EOF时，即末尾时，停止     Formatted strings  int sscanf(char *strin">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-01-09T09:12:16.000Z">
<meta property="article:modified_time" content="2022-01-09T09:12:41.952Z">
<meta property="article:author" content="BUTLER36">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/blog/atom.xml" title="BUTLER36HUS&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/blog/css/style.css">

  <!-- Katex -->
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css" integrity="sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs" crossorigin="anonymous">

  <!-- The loading of KaTeX is deferred to speed up page rendering -->
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js" integrity="sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx" crossorigin="anonymous"></script>

  <!-- To automatically render math in text elements, include the auto-render extension: -->
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"
      onload="renderMathInElement(document.body,{
        delimiters: [
            {left: '$$', right: '$$', display: true},
            {left: '$', right: '$', display: false},
        ],});"></script>
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/blog/" id="logo">BUTLER36HUS&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/blog/">Home</a>
        
          <a class="main-nav-link" href="/blog/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/blog/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://BUTLER36HUS.github.io/blog"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Lab03-Struct" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/blog/2022/01/09/Lab03-Struct/" class="article-date">
  <time datetime="2022-01-09T09:12:16.000Z" itemprop="datePublished">2022-01-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Lab03_Struct
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="ICS-53"><a href="#ICS-53" class="headerlink" title="ICS-53"></a>ICS-53</h1><h2 id="Struct"><a href="#Struct" class="headerlink" title="Struct"></a>Struct</h2><h3 id="lt-stdio-h-gt"><a href="#lt-stdio-h-gt" class="headerlink" title="&lt;stdio.h&gt;"></a>&lt;stdio.h&gt;</h3><h3 id="Strings-amp-lt-string-h-gt"><a href="#Strings-amp-lt-string-h-gt" class="headerlink" title="Strings &amp; &lt;string.h&gt;"></a>Strings &amp; &lt;string.h&gt;</h3><ul>
<li><p>Copy</p>
<ul>
<li>strcpy</li>
</ul>
</li>
<li><p>strlen</p>
</li>
<li><p>strchr ≈ python find()</p>
</li>
<li><p>loop</p>
<ul>
<li><code>for(char* i=line;*i;++i)</code><ul>
<li>当<code>*i==\EOF</code>时，即末尾时，停止</li>
</ul>
</li>
</ul>
</li>
<li><p>Formatted strings</p>
<ul>
<li>int sscanf(char *string, char *format, …)</li>
<li>int sprinf(char *buffer, char *format, …)</li>
<li>all return the number of successful characters</li>
</ul>
</li>
</ul>
<h3 id="Structs"><a href="#Structs" class="headerlink" title="Structs"></a>Structs</h3><ul>
<li>types can be defined<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span><span class="keyword">int</span> x; <span class="keyword">int</span> y&#125; Point; </span><br><span class="line">Point p;</span><br><span class="line">p.x = <span class="number">0</span>; p.y =<span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
<li>Overall size is sum of elements and paddings in between<ul>
<li>```C<br>struct {<pre><code>char x;
int y;
char z;
</code></pre>
} s1;<br>sizeof(s1) != 1+4+1 // == 12 = 4(char+padding=3)+4(int)+4(char+padding=3)<br>struct {<pre><code>char x,z;
int y;
</code></pre>
} s2;<br>sizeof(s2) != 1+4+1 // == 8 = 4(char+char+padding=2)+4(int)<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    - word alignment here</span><br><span class="line">      - It benefits array</span><br><span class="line">- can model real memory layout</span><br><span class="line">```C</span><br><span class="line">    typedef struct &#123;</span><br><span class="line">        int a:2; //size in bits</span><br><span class="line">        int b:1;</span><br><span class="line">    &#125; Complex</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>bit fields</li>
<li>Deferencing pointers to struct elements<ul>
<li><code>(*structPtr).element</code></li>
<li><code>structPtr-&gt;element</code></li>
</ul>
</li>
</ul>
<h4 id="Union"><a href="#Union" class="headerlink" title="Union"></a>Union</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">u</span>-<span class="title">tag</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> iv</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>like structs</li>
<li>occpy same memory space<ul>
<li>无论读哪个element，都按头地址读</li>
</ul>
</li>
<li>can hold different types at different times</li>
<li>overall size is largest of elements</li>
</ul>
<h4 id="Memory-Pitfalls-常见错误"><a href="#Memory-Pitfalls-常见错误" class="headerlink" title="Memory Pitfalls 常见错误"></a>Memory Pitfalls 常见错误</h4><ul>
<li>Dereferencing bad pointers<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,val); <span class="comment">//should be &amp;val</span></span><br></pre></td></tr></table></figure></li>
<li>Reading Uninitialized Memory<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *y = <span class="built_in">malloc</span>(...)</span><br><span class="line">y[<span class="number">0</span>] += <span class="number">1</span>; <span class="comment">// 需要初始化 y[0]</span></span><br><span class="line">```  </span><br><span class="line">- Overwriting Memory</span><br><span class="line">```C</span><br><span class="line"><span class="keyword">int</span> **p;</span><br><span class="line">p = <span class="built_in">malloc</span>(N*<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;N;++i)</span><br><span class="line">    p[i] = <span class="built_in">malloc</span>(M*<span class="keyword">sizeof</span>(<span class="keyword">int</span>))</span><br></pre></td></tr></table></figure></li>
<li>referencing a pointer instend of value<ul>
<li>should it be <code>*p</code> or just <code>p</code>?</li>
</ul>
</li>
<li>referencing Nonexistent variables<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="keyword">return</span> &amp;val; <span class="comment">// 该内存返回时已经去掉</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>free one block multiple times</li>
<li>referencing freed blocks</li>
<li>failling to free allocated blocks</li>
<li>free only parts of data structure<ul>
<li>比如链表只free head</li>
</ul>
</li>
</ul>
<h5 id="DEALING-with-bugs"><a href="#DEALING-with-bugs" class="headerlink" title="DEALING with bugs"></a>DEALING with bugs</h5><ul>
<li>gdb</li>
<li>Valgrind</li>
<li>glibc mallloc contains checking code<ul>
<li><code>setenv MALLOC_CHECK_ 3</code></li>
</ul>
</li>
</ul>
<h3 id="The-Lost-Art-of-Structure-Packing-笔记"><a href="#The-Lost-Art-of-Structure-Packing-笔记" class="headerlink" title="The Lost Art of Structure Packing 笔记"></a>The Lost Art of Structure Packing 笔记</h3><ul>
<li><a target="_blank" rel="noopener" href="http://www.catb.org/esr/structure-packing/">Link to the Article</a></li>
<li>ASSUME x86 or ARM or any with <em>self-alignment</em></li>
</ul>
<h4 id="1-Who-should-read-this"><a href="#1-Who-should-read-this" class="headerlink" title="1. Who should read this"></a>1. Who should read this</h4><h4 id="2-Why-I-wrote-it"><a href="#2-Why-I-wrote-it" class="headerlink" title="2. Why I wrote it"></a>2. Why I wrote it</h4><h4 id="3-Alignment-requirement"><a href="#3-Alignment-requirement" class="headerlink" title="3. Alignment requirement"></a>3. Alignment requirement</h4><ul>
<li> the way your compiler lays out basic datatypes in memory is constrained in order <strong>to make memory accesses faster</strong></li>
<li>each type except char has an <em><strong>alignment requirement</strong></em>; <ul>
<li> 任何type的地址都必须被<code>sizeof(type)</code>整除</li>
<li> Ex: 2-byte shorts must start on an even address, </li>
<li> 4-byte ints or floats must start on an address divisible by 4,</li>
<li> <em>Signed or unsigned makes no difference</em></li>
<li> The jargon for this is that basic C types on x86 and ARM are <em><strong>self-aligned</strong></em>. </li>
<li> Pointers, whether 32-bit (4-byte) or 64-bit (8-byte) are <em>self-aligned</em> too.</li>
</ul>
</li>
<li>Self-alignment makes access faster because it facilitates generating <em><strong>single-instruction fetches</strong></em> and puts of the typed data. </li>
<li>on some <em><strong>older ones</strong></em> forcing your C program to violate alignment rules didn’t just slow your code down, it caused <strong>an illegal instruction fault</strong>. </li>
<li>Also, self-alignment is <strong>not the only</strong> possible rule.</li>
<li>NTP默认有alignment<ul>
<li>platforms with padding rules other than self-alignment are <ul>
<li>either nonexistent or </li>
<li>confined to such specialized niches that they’re never either NTP servers or clients.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="4-Padding"><a href="#4-Padding" class="headerlink" title="4. Padding"></a>4. Padding</h4><p>In fact, the hidden assumption that the <em><strong>allocated order of static variables is their source order</strong></em> is not necessarily valid</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s</span>&#123;</span></span><br><span class="line">  <span class="keyword">char</span> *p;</span><br><span class="line">  <span class="keyword">char</span> c;</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Here’s what actually happens. The storage for p starts on a self-aligned 4- or 8-byte boundary depending on the machine word size. This is <em><strong>pointer alignment</strong></em> - the strictest possible.<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *p;      <span class="comment">/* 4 or 8 bytes */</span></span><br><span class="line"><span class="keyword">char</span> c;       <span class="comment">/* 1 byte */</span></span><br><span class="line"><span class="keyword">char</span> pad[<span class="number">3</span>];  <span class="comment">/* 3 bytes */</span></span><br><span class="line"><span class="keyword">int</span> x;        <span class="comment">/* 4 bytes */</span></span><br></pre></td></tr></table></figure></li>
<li>The <code>pad[3]</code> character array represents the fact that there are three bytes of <strong>waste space</strong> in the structure.  <ul>
<li>The old-school term for this was “slop”. </li>
<li>The value of the padding bits is <strong>undefined</strong>; <ul>
<li>in particular <em><strong>it is not guaranteed that they will be zeroed</strong></em>.<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="keyword">char</span> pad1[M];</span><br><span class="line"><span class="keyword">char</span> *p;</span><br><span class="line"><span class="keyword">char</span> pad2[N];</span><br><span class="line"><span class="keyword">int</span> x;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>what can we say about M and N?<ul>
<li>First, in this case <code>N</code> will be zero</li>
<li>The value of <code>M</code> is <strong>less predictable</strong>.<ul>
<li><em>If the compiler happened to map c to the last byte of a machine word, the next byte (the first of p) would be the first byte of the next one and properly pointer-aligned. M would be zero.</em></li>
<li>It is more likely that c will be mapped to the <strong>first byte of a machine word</strong>. In that case M will be whatever padding is needed to ensure that <strong>p has pointer alignment</strong> - 3 on a 32-bit machine, 7 on a 64-bit machine.</li>
</ul>
</li>
</ul>
</li>
<li>On a platform with self-aligned types, <strong>arrays</strong> of char/short/int/long/pointer have <strong>no internal padding</strong>;<ul>
<li>each member is automatically self-aligned at the end of the next one</li>
</ul>
</li>
<li>same to <strong>Go structs</strong>, and to <strong>Rust structs with the “repr(C)” attribute</strong>, with only syntactic changes.</li>
</ul>
<h4 id="5-Structure-alignment-and-padding"><a href="#5-Structure-alignment-and-padding" class="headerlink" title="5. Structure alignment and padding"></a>5. Structure alignment and padding</h4><ul>
<li>In general, a struct instance will have <em><strong>the alignment of its widest scalar member</strong></em>. <ul>
<li>Compilers do this as the easiest way to <strong>ensure that all the members are self-aligned for fast access</strong>.</li>
</ul>
</li>
<li>in C (and Go, and Rust) <strong>there is no leading padding</strong>.  <ul>
<li>In C++ this may not be true; <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo1</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *p;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">long</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/* On 64-bit sizeof(void *)==8 */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo1</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *p;     <span class="comment">/* 8 bytes */</span></span><br><span class="line">    <span class="keyword">char</span> c;      <span class="comment">/* 1 byte*/</span></span><br><span class="line">    <span class="keyword">char</span> pad[<span class="number">7</span>]; <span class="comment">/* 7 bytes */</span></span><br><span class="line">    <span class="keyword">long</span> x;      <span class="comment">/* 8 bytes */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h4 id="Trailing-Padding"><a href="#Trailing-Padding" class="headerlink" title="Trailing Padding"></a>Trailing Padding</h4><ul>
<li><p><strong>stride address of a structure</strong></p>
<ul>
<li>It is the first address following the structure data that has the same alignment as the structure.</li>
</ul>
</li>
<li><p>The general rule of trailing structure padding is this: the compiler will behave as though the structure has trailing padding out to its stride address</p>
</li>
<li><p>If your structure has <strong>structure members</strong>, the inner structs want to have the alignment of <strong>longest scalar</strong> too</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo5</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">foo5_inner</span> &#123;</span></span><br><span class="line">        <span class="keyword">char</span> *p;</span><br><span class="line">        <span class="keyword">short</span> x;</span><br><span class="line">    &#125; inner;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
<li><p>The char *p member in the inner struct forces the <strong>outer struct to be pointer-aligned as well as the inner</strong></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo5</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;           <span class="comment">/* 1 byte*/</span></span><br><span class="line">    <span class="keyword">char</span> pad1[<span class="number">7</span>];     <span class="comment">/* 7 bytes */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">foo5_inner</span> &#123;</span></span><br><span class="line">        <span class="keyword">char</span> *p;      <span class="comment">/* 8 bytes */</span></span><br><span class="line">        <span class="keyword">short</span> x;      <span class="comment">/* 2 bytes */</span></span><br><span class="line">        <span class="keyword">char</span> pad2[<span class="number">6</span>]; <span class="comment">/* 6 bytes */</span></span><br><span class="line">    &#125; inner;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li>This structure gives us a hint of <strong>the savings that might be possible from repacking structures</strong>. <ul>
<li>Of 24 bytes, 13 of them are padding. That’s more than 50% waste space!</li>
</ul>
</li>
</ul>
<h4 id="6-Bitfields"><a href="#6-Bitfields" class="headerlink" title="6. Bitfields"></a>6. Bitfields</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo6</span> &#123;</span></span><br><span class="line">    <span class="keyword">short</span> s;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">int</span> flip:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> nybble:<span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> septet:<span class="number">7</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>What they give you the ability to do is declare structure fields of smaller than character width, down to 1 bit, like this.</p>
</li>
<li><p>The thing to know about bitfields is that they are implemented with word- and byte-level mask and rotate instructions operating on machine words, and <strong>cannot cross word boundaries</strong>.</p>
<ul>
<li>C99 guarentees that bit-fields will be packed as tightly as possible, provided they don’t cross storage unit boundaries</li>
<li>This restriction is relaxed in C11 (6.7.2.1p11) and C++14 ([class.bit]p1); <ul>
<li>It’s up to the implementation to decide;<ul>
<li>GCC leaves it up to the ABI, which for x64 does prevent them from sharing an allocation unit.<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 32-bit machine */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo6</span> &#123;</span></span><br><span class="line">    <span class="keyword">short</span> s;       <span class="comment">/* 2 bytes */</span></span><br><span class="line">    <span class="keyword">char</span> c;        <span class="comment">/* 1 byte */</span></span><br><span class="line">    <span class="keyword">int</span> flip:<span class="number">1</span>;    <span class="comment">/* total 1 bit */</span></span><br><span class="line">    <span class="keyword">int</span> nybble:<span class="number">4</span>;  <span class="comment">/* total 5 bits */</span></span><br><span class="line">    <span class="keyword">int</span> pad1:<span class="number">3</span>;    <span class="comment">/* pad to an 8-bit boundary */</span></span><br><span class="line">    <span class="keyword">int</span> septet:<span class="number">7</span>;  <span class="comment">/* 7 bits */</span></span><br><span class="line">    <span class="keyword">int</span> pad2:<span class="number">25</span>;   <span class="comment">/* pad to 32 bits */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>As with normal structure padding, the padding bits <strong>are not guaranteed to be zero</strong>; C99 mentions this</p>
</li>
<li><p>The base type of a bit field is interpreted for <strong>signedness</strong> but not necessarily for <strong>size</strong>.</p>
<ul>
<li>It is up to implementors <ul>
<li>whether “short flip:1” or “long flip:1” are supported, </li>
<li>whether those base types change the size of the storage unit the field is packed into.</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo7</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> bigfield:<span class="number">31</span>;      <span class="comment">/* 32-bit word 1 begins */</span></span><br><span class="line">    <span class="keyword">int</span> littlefield:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo8</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> bigfield1:<span class="number">31</span>;     <span class="comment">/* 32-bit word 1 begins /*</span></span><br><span class="line"><span class="comment">    int littlefield1:1;</span></span><br><span class="line"><span class="comment">    int bigfield2:31;     /* 32-bit word 2 begins */</span></span><br><span class="line">    <span class="keyword">int</span> littlefield2:<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo9</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> bigfield1:<span class="number">31</span>;     <span class="comment">/* 32-bit word 1 begins */</span></span><br><span class="line">    <span class="keyword">int</span> bigfield2:<span class="number">31</span>;     <span class="comment">/* 32-bit word 2 begins */</span></span><br><span class="line">    <span class="keyword">int</span> littlefield1:<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> littlefield2:<span class="number">1</span>;   <span class="comment">/* 32-bit word 3 begins */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>Again, C11 and C++14 may pack <code>foo9</code> tighter, but it would perhaps be <em><strong>unwise</strong></em> to count on this.</li>
</ul>
<h4 id="7-Structure-reordering"><a href="#7-Structure-reordering" class="headerlink" title="7. Structure reordering"></a>7. Structure reordering</h4><ul>
<li><p>The first thing to notice is that slop only happens in two places. </p>
<ol>
<li>One is where storage bound to a larger data type (with stricter alignment requirements) follows storage bound to a smaller one. </li>
<li>The other is where a struct naturally ends before its stride address, requiring padding so the next one will be properly aligned</li>
</ol>
</li>
<li><p>The simplest way to eliminate slop is to reorder the structure members by <strong>decreasing alignment</strong>. </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo10</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">foo10</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">short</span> x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo10</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> c;          <span class="comment">/* 1 byte */</span></span><br><span class="line">    <span class="keyword">char</span> pad1[<span class="number">7</span>];    <span class="comment">/* 7 bytes */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">foo10</span> *<span class="title">p</span>;</span> <span class="comment">/* 8 bytes */</span></span><br><span class="line">    <span class="keyword">short</span> x;         <span class="comment">/* 2 bytes */</span></span><br><span class="line">    <span class="keyword">char</span> pad2[<span class="number">6</span>];    <span class="comment">/* 6 bytes */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>24 bytes TO 16 bytes</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo11</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">foo11</span> *<span class="title">p</span>;</span></span><br><span class="line">    <span class="keyword">short</span> x;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">foo11</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">foo11</span> *<span class="title">p</span>;</span> <span class="comment">/* 8 bytes */</span></span><br><span class="line">    <span class="keyword">short</span> x;         <span class="comment">/* 2 bytes */</span></span><br><span class="line">    <span class="keyword">char</span> c;          <span class="comment">/* 1 byte */</span></span><br><span class="line">    <span class="keyword">char</span> pad[<span class="number">5</span>];     <span class="comment">/* 5 bytes */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>Reordering is not guaranteed to produce saving</p>
</li>
<li><p>Curiously, strictly ordering your structure fields <strong>by increasing size</strong> also works to mimimize padding. </p>
</li>
<li><p>Why, if reordering for minimal slop is so simple, C compilers <strong>don’t do it automatically</strong>?</p>
<ul>
<li>Automatic reordering would <strong>interfere</strong> with a systems programmer’s ability to lay out structures that exactly match the byte and bit-level layout of memory-mapped device control block</li>
<li> <strong>Rust</strong> makes the opposite choice; by default, its compiler <em>may</em> reorder structure fields.</li>
</ul>
</li>
</ul>
<h4 id="8-未完待续"><a href="#8-未完待续" class="headerlink" title="8~ 未完待续"></a>8~ 未完待续</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://butler36hus.github.io/blog/2022/01/09/Lab03-Struct/" data-id="cky71gon40001j0rtfell4als" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/blog/2022/01/09/WK01-DigitalCamera/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          WK01_DigitalCamera
        
      </div>
    </a>
  
  
    <a href="/blog/2022/01/09/Lab02-Pointers-Memory/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Lab02_Pointers&amp;Memory</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2022/01/">一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/blog/archives/2021/12/">十二月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/blog/2022/01/09/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/blog/2022/01/09/WK01-DigitalCamera/">WK01_DigitalCamera</a>
          </li>
        
          <li>
            <a href="/blog/2022/01/09/Lab03-Struct/">Lab03_Struct</a>
          </li>
        
          <li>
            <a href="/blog/2022/01/09/Lab02-Pointers-Memory/">Lab02_Pointers&amp;Memory</a>
          </li>
        
          <li>
            <a href="/blog/2021/12/21/TIP-%E5%B0%86hexo%E7%94%9F%E6%88%90%E7%9A%84%E5%8D%9A%E5%AE%A2%E7%BD%91%E9%A1%B5%E6%94%BE%E5%9C%A8Github-io%E5%AD%90%E7%9B%AE%E5%BD%95-Put-hexo-generated-blog-pages-into-subdirectories-of-Github-Pages/">TIP-将hexo生成的博客网页放在Github.io子目录</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 BUTLER36<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/blog/" class="mobile-nav-link">Home</a>
  
    <a href="/blog/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/blog/fancybox/jquery.fancybox.css">

  
<script src="/blog/fancybox/jquery.fancybox.pack.js"></script>




<script src="/blog/js/script.js"></script>




  </div>
</body>
</html>